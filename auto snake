<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Snake Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: black;
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace; /* Set font to Courier New */
        }
        canvas {
            background-color: black;
            border: 2px solid white; /* Added a border to the canvas */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="320" height="320"></canvas>
    
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        const tileSize = 16;
        const tileCount = canvas.width / tileSize;

        let snake = [{ x: tileSize * 5, y: tileSize * 5 }];
        let direction = { x: 1, y: 0 };
        let apple = generateRandomApple();
        let score = 0;

        function gameLoop() {
            // Move the snake in the current direction
            let head = {
                x: snake[0].x + direction.x * tileSize,
                y: snake[0].y + direction.y * tileSize
            };

            // Check for wall collisions
            if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
                resetGame();  // Reset if collision with wall detected
                return; // Exit the loop
            }

            // Check if snake eats the apple
            if (head.x === apple.x && head.y === apple.y) {
                snake.unshift(head);  // Grow snake by adding new head
                apple = generateRandomApple();  // Generate new apple
                score++;  // Increment score
            } else {
                snake.pop();  // Remove last segment if not growing
                snake.unshift(head);  // Add new head position
            }

            // Check for collisions with itself
            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
                resetGame();  // Reset if collision detected
            }

            drawGame();
        }

        function generateRandomApple() {
            let newApple;
            do {
                newApple = {
                    x: Math.floor(Math.random() * tileCount) * tileSize,
                    y: Math.floor(Math.random() * tileCount) * tileSize
                };
            } while (snake.some(segment => segment.x === newApple.x && segment.y === newApple.y)); // Ensure apple is not on the snake
            return newApple;
        }

        function resetGame() {
            snake = [{ x: tileSize * 5, y: tileSize * 5 }];
            direction = { x: 1, y: 0 };
            apple = generateRandomApple();
            score = 0;
        }

        function drawGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw apple
            ctx.fillStyle = "red";
            ctx.fillRect(apple.x, apple.y, tileSize, tileSize);

            // Draw snake without breaks between segments
            ctx.fillStyle = "#00ff00";
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                ctx.fillRect(segment.x, segment.y, tileSize, tileSize);
            }

            // Display score
            ctx.fillStyle = "white";
            ctx.font = "20px 'Courier New'"; // Set font to Courier New for the score
            ctx.fillText(`Score: ${score}`, 10, 20);
        }

        function findBestDirection() {
            const possibleDirections = [
                { x: 0, y: -1 },  // Up
                { x: 0, y: 1 },   // Down
                { x: -1, y: 0 },  // Left
                { x: 1, y: 0 }    // Right
            ];

            // Find the best direction to the apple
            let bestDirection = null;
            let minDistance = Infinity;

            for (const newDir of possibleDirections) {
                const newHead = {
                    x: snake[0].x + newDir.x * tileSize,
                    y: snake[0].y + newDir.y * tileSize
                };

                // Check if the new head position is valid (not colliding with itself and within walls)
                if (
                    newHead.x >= 0 && newHead.x < canvas.width &&
                    newHead.y >= 0 && newHead.y < canvas.height &&
                    !snake.some(segment => segment.x === newHead.x && segment.y === newHead.y)
                ) {
                    const distance = Math.abs(newHead.x - apple.x) + Math.abs(newHead.y - apple.y);

                    if (distance < minDistance) {
                        minDistance = distance;
                        bestDirection = newDir;
                    }
                }
            }

            if (bestDirection) {
                direction = bestDirection; // Change the snake's direction to the best one
            }
        }

        function automatedMovement() {
            findBestDirection();  // Automatically find the best direction towards the apple
        }

        setInterval(() => {
            automatedMovement();
            gameLoop();
        }, 100);  // Set game speed
    </script>
</body>
</html>
